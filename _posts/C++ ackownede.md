## C++

### C语言知识

#### 1、C 与 C++ 的区别

- C是面向过程的语言，是一个结构化的语言，考虑如何通过一个过程对输入进行处理得到输出。C++是面向对象的语言，主要特征是“封装、继承和多态”。封装隐藏了实现细节，使得代码模块化；派生类可以继承父类的数据和方法，扩展了已经存在的模块，实现了代码重用；多态则是“一个接口，多种实现”，通过派生类重写父类的虚函数，实现了接口的重用。
- C 和 C++ 动态管理内存的方法不一样，C是使用`malloc/free`，而 C++ 除此之外还有`new/delete`关键字。
- C++ 支持函数重载，C 不支持函数重载
- C++ 中有引用，C 中不存在引用的概念





#### 2、extern“C”作用

extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。





#### 3、C语言的函数调用过程

函数的调用过程：

1）从栈空间分配存储空间

2）从实参的存储空间复制值到形参栈空间

3）进行运算

形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。

数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。

当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址/指针传递。

传值：传值，实际是把实参的值赋值给行参，相当于copy。那么对行参的修改，不会影响实参的值 

传址： 实际是传值的一种特殊方式，只是他传递的是地址，不是普通的赋值，那么传地址以后，实参和行参都指向同一个对象，因此对形参的修改会影响到实参。





#### 4、`sizeof`和`strlen`

##### **1、sizeof操作符**

`sizeof`计算的是在栈中分配的内存大小。

（1） `sizeof`不计算static变量占的内存；

（2） 32位系统的指针的大小是4个字节，64位系统的指针是8字节，而不用管指针类型；

（3） char型占1个字节，int占4个字节，short int占2个字节

long int占4个字节，float占4字节，double占8字节，string占4字节

一个空类占1个字节，单一继承的空类占1个字节，虚继承涉及到虚指针所以占4个字节

（4） 数组的长度：

若指定了数组长度，则不看元素个数，总字节数=数组长度*sizeof（元素类型）

若没有指定长度，则按实际元素个数类确定

Ps：若是字符数组，则应考虑末尾的空字符。

（5） 结构体对象的长度

在默认情况下，为方便对结构体内元素的访问和管理，当结构体内元素长度小于处理器位数的时候，便**以结构体内最长的数据元素的长度为对齐单位**，即为其整数倍。若结构体内元素长度大于处理器位数则以处理器位数为单位对齐。

栗子：结构体里有一个int，一个short，一个char，sizeof大小为12字节

（6） unsigned影响的只是最高位的意义，数据长度不会改变，所以sizeof(unsigned int) == 4

（7） 自定义类型的sizeof取值等于它的类型原型取sizeof

（8） 对函数使用sizeof，在编译阶段会被函数的返回值的类型代替

（9） sizeof后如果是类型名则必须加括号，如果是变量名可以不加括号，这是因为sizeof是运算符

（10） 当使用结构类型或者变量时，sizeof返回实际的大小。当使用静态数组时返回数组的全部大小，sizeof不能返回动态数组或者外部数组的尺寸



##### 2、strlen

`strlen`是C语言的库函数，计算的是字符串的实际长度，不包括结尾的 ’\0‘。

参数必须是以’\0‘为结尾的字符串。



手动实现

```c++
int strlen(const char *str)
{
	assert(str! = NULL);
	int len = 0;
	while(str != '\0'){
        ++ str;	++ len;
	}
	return len;
}
```





##### 3、sizeof和strlen的区别

1. sizeof是一个操作符，而strlen是库函数。
2. sizeof的参数可以是数据类型或变量，而strlen的参数只能是以’\0‘为结尾的字符串。
3. sizeof计算的是数据类型或变量占内存的大小，而strlen计算的是字符串的实际长度，不包括结尾的 ’\0‘。
4. sizeof在编译时计算结果，而strlen的结果必须在运行时得出。
5. 数组作为sizeof的参数时不退化，传递给strlen时退化为指针。





#### 5、`strcat`

`strcnt`为字符串拼接函数，在`<string.h>`中，函数原型如下：

```c++
char* strcat(char* strDestination, const char* strSource);
```

1、参数说明：

- `strDestination`：目的字符串；

- `strSource`：源字符串。

- 返回：指向 `strDestination` 的指针。

  

**`strcat()`** 函数把 strSource 所指向的字符串追加到 strDestination 所指向的字符串的结尾，所以必须要保证 strDestination 有足够的内存空间来容纳两个字符串，否则会导致溢出错误。

注意：

1）缓冲区 与 目的字符串所指的内存空间不能重叠，且 dest 要有足够的空间来容纳要复制的字符串。

2）strDestination 末尾的`\0`会被覆盖，strSource 末尾的`\0`会一起被复制过去，最终的字符串只有一个`\0`。





2、手动实现`strcnt()`函数

```c++
#include <assert.h>

char* strcnt(char* Dest, const char* Src)
{//注：原函数就没有长度判定
    //assert(Dest != nullptr && Src != nullptr);
    if(Dest == nullptr || Src == nullptr) return Dest;
    if(Dest == Src) return Dest;
    
    char* ret = Dest;
    while(*Dest != '\0') Dest ++;
    while(*Src != '\0'){
        *Dest = *Src;
        *Dest ++, *Src ++;
    }
    *Dest = '\0';
    return ret;
}
```







#### 6、`strcpy`

```c++
char *strcpy(char *dst, const char const *src);
//C语言标准库函数strcpy，把从src地址开始且含有'\0'结束符的字符串复制到以dest开始的地址空间
//注：这个函数没有字符串长度合法判定，而且是个不安全的函数
```

1、这个函数使用需要注意的地方

- 源字符串和目的字符串的存储地址不能有重叠，若出现重叠，其结果是未定义的
- 源字符串长度不能比缓冲区长度更长，因为这个函数没有字符串长度合法判定
- 目的缓冲区是要修改的地方，故`dst`不能是`const`的
- 这个函数将字符串`src`后面的字符串结束符`'\0'`一起复制给`dst`，但是在读取`dst`时由于遇到`'\0'`就会返回，所以不会注意到后面可能还有`'\0'`



2、手动实现`strcpy()`函数

```c++
char *strcpy(char *strDest, const char *strSrc)
{ //注：原函数就没有长度判定
    if ( strDest == NULL || strSrc == NULL)
   		return NULL ;
    if ( strDest == strSrc)
    	return strDest ;
    char *tempptr = strDest ;
    while(*strSrc!='\0'){
        *strDest = *strSrc;
        *strDest++,  *strSrc++;
    }
    //while( (*strDest++ = *strSrc++) != '\0');
    *strDest = '\0';
    return tempptr;
}
```



3、更为安全的`strcpy_s`函数

`c++`提供的`strcpy_s`函数包含在头文件`<string.h>`中

```c++
_ACRTIMP errno_t __cdecl strcpy_s(
        _Out_writes_z_(_SizeInBytes) char*       _Destination,
        _In_                         rsize_t     _SizeInBytes,
        _In_z_                       char const* _Source
        );
```

第一个参数：目标字符串指针

第二个参数：目标缓冲区的实际大小，可使用`strlen()`函数直接求出，切记，在使用`strlen()`求出字符串长度时，勿忘+1

第三个参数：输入字符串指针



一个栗子：

```c++
strcpy_s(str, len+1, s); //将s中字符串复制到str，最后一个空间为'\0'结束符
```











#### 7、`strncpy`

```c++
char *strncpy(char *dest, const char *src, size_t n)
```

1、函数介绍

- **`dest`** -- 指向用于存储复制内容的目标数组。

- **`src`** -- 要复制的字符串。

- **n** -- 要从源中复制的字符数。

  

  该函数返回最终复制的字符串。

注意：

1）库函数 **`strncpy`** 把 **`src`** 所指向的字符串复制到 **`dest`**，最多复制 **n** 个字符。

2)  当`dest`和`src`在内存中有重叠时，结果将是未定义的

3）当 `src` 的长度小于 n 时，`dest` 的剩余部分将用空字节(`‘\0’`)填充。

4）`strncpy`是不负责检测 n`是否大于dest`长度的，因此当n的长度大于strlen(dest)时会破坏后面的内存，因为`strncpy`总是复制`n`个字符到`dest`指向的内存！！！



2、手动实现`strncpy()`函数

1）不考虑内存重叠

```c++
char* strncpy(char* dest, const char* src, size_t n){
    assert(dest != nullptr && src != nullptr);
    char* res = dest;
    int offset = 0; // 多余的部分补空字节
    int len = str(src);
    if(len < n){
        offset = n - len;
        n = len;
    }
    while(n --) 
        *dest ++ = *src ++;
    
    while(offset --) 
        *dest ++ = '\0';
    
    return res;
}
```

2）考虑内存重叠

```c++
char* strncpy(char* dest, const char* src, size_t n){
    assert(dest != nullptr && src != nullptr);
    char* res = dest;
    int offset = 0; // 多余的部分补空字节
    int len = str(src);
    if(len < n){
        offset = n - len;
        n = len;
    }
    char* tmp;
    if(dest >= src && dest <= src + n - 1)
    { // 重叠，从后向前复制
        dest = dest + n - 1;
        src = src + n - 1;
        tmp = dest;
        while(n --) *dest -- = *src --;
    }else{
        while(n --) 
        	*dest ++ = *src ++;
        tmp = dest;
    }

    while(offset --) 
        *tmp ++ = '\0';
    
    return res;
}
```









#### 8、`memset`

```c++
void *memset(void *str, int c, size_t n)
```

复制字符 **c**（一个无符号字符）到参数 **str** 所指向的字符串的前 **n** 个字符。

参数：

- **str** -- 指向要填充的内存块。
- **c** -- 要被设置的值。该值以 int 形式传递，但是函数在填充内存块时是使用该值的无符号字符形式。
- **n** -- 要被设置为该值的字符数。

返回一个指向存储区 str 的指针。

`memset`可以高效地将数组清空，或者赋值

```c++
int a[100];
memset(a, 0, sizeof a); // 将a数组每一位赋0
memser(a, 0x3f, sizeof a); // 将a数组每一位赋0x3f3f3f3f
// 因为第二个参数是逐字节赋值，即对一个int的四个字节，每一个字节都赋值为0x3f
// 因此数组里的每一位都是0x3f3f3f3f
```







#### 9、`memcpy`

```c++
void *memcpy(void *dest, const void *str, size_t n)
```

内存复制函数：从存储区 **str** 复制 **n** 个字节到存储区 **dest**。

- **dest** -- 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。
- **str** -- 指向要复制的数据源，类型强制转换为 void* 指针。
- **n** -- 要被复制的字节数。

返回一个指向目标存储区 dest 的指针。

注意： 注意当内存有重叠时，src部分会被覆盖



手动实现

```c++
void *memcpy(void *dest, const void *str, size_t n){
	if(dest == NULL && src == NULL) return NULL;

	char *d = (char*)dest;
	char *s = (char*)src;
	while(n--)
        *d ++ = *s ++;
    
	return dest;
}
```







#### 10、sprintf、strcpy 及 memcpy比较

问：完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，这些函数的区别

答：这些函数的区别在于 实现功能以及操作对象不同。

（1）**strcpy** 函数操作的对象是字符串，完成从源字符串到目的字符串的拷贝功能。

（2）**sprintf** 函数操作的对象不限于字符串：虽然目的对象是字符串，但是源对象可以是字符串、也可以是任意基本类型的数据。这个函数主要用来实现（字符串或基本数据类型）向字符串的转换功能。如果源对象是字符串，并且指定 %s 格式符，也可实现字符串拷贝功能。

（3）**memcpy** 函数顾名思义就是内存拷贝，实现将一个内存块的内容复制到另一个内存块这一功能。内存块由其首地址以及长度确定。程序中出现的实体对象，不论是什么类型，其最终表现就是在内存中占据一席之地（一个内存区间或块）。因此，memcpy的操作对象不局限于某一类数据类型，或者说可适用于任意数据类型，只要能给出对象的起始地址和内存长度信息、并且对象具有可操作性即可。鉴于memcpy函数等长拷贝的特点以及数据类型代表的物理意义，memcpy 函数通常限于同种类型数据或对象之间的拷贝，其中当然也包括字符串拷贝以及基本数据类型的拷贝。



对于字符串拷贝来说，用上述三个函数都可以实现，但是其实现的效率和使用的方便程度不同：

• strcpy 无疑是最合适的选择：效率高且调用方便。

• sprintf 要额外指定格式符并且进行格式转化，麻烦且效率不高。

• memcpy 虽然高效，但是需要额外提供拷贝的内存长度这一参数，易错且使用不便；并且如果长度指定过大的话（最优长度是源字符串长度 + 1），还会带来性能的下降。其实 strcpy 函数一般是在内部调用 memcpy 函数或者用汇编直接实现的，以达到高效的目的。因此，使用 memcpy 和 strcpy 拷贝字符串在性能上应该没有什么大的差别。



对于非字符串类型的数据的复制来说，strcpy 和 snprintf 一般就无能为力了，可是对 memcpy 
却没有什么影响。但是，对于基本数据类型来说，尽管可以用 memcpy 进行拷贝，由于有赋值运算符可以方便且高效地进行同种或兼容类型的数据之间的拷贝，所以这种情况下 memcpy 几乎不被使用 。memcpy 的长处是用来实现（通常是内部实现居多）对结构或者数组的拷贝，其目的是或者高效，或者使用方便，甚或两者兼有。





#### 11、<file.h> 和  "file.h" 的区别

　　前者是从标准库路径寻找

　　后者是从当前工作路径

\#include < >格式：引用标准库头文件，编译器从标准库目录开始查找。
		#incluce " "格式：引用非标准库的头文件，编译器先从用户的工作目录开始搜索，找不到后才会去系统配置的库环境变量和用户配置的路径去搜索。







#### 12、动态库与静态库的区别

静态库：链接时放入程序，可产生多个副本

动态库：程序运行时加载，多线程共享





#### 13、定义和声明的区别

声明是告诉编译器变量的类型和名字，不会为变量分配空间

定义需要分配空间，同一个变量可以被声明多次，但是只能被定义一次









#### 14、**c cc cpp hpp inl 这些后缀名都有什么区别?**

C中：

头文件后缀名： .h

源文件后缀名： .c

C++中：

头文件后缀名： .h, .hpp, .hxx

源文件后缀名：.cpp, .cc, .cxx, .C .c++

只是个名称，我们自己知道哪些是同一个东西，能区别开c和c++就行了。

另外，.h和.hpp的区别是：*.h里面只有声明，没有实现，而*.hpp里声明实现都有，后者可以减少.cpp的数量，适合用来编写公用的开源库。

inl 文件是内联函数的源文件。内联函数通常在c++头文件中实现，但有的时候**内联函数较多**或者出于一些别的考虑（使头文件看起来更简洁等），往往会将这部分具体**定义的代码添加到INL文件中**，然后**在该头文件的末尾将其用#include引入**。由此也可以看到inl文件的例外一个用法的影子——**模板函数、模板类的定义代码的存放**。







#### 15、**gcc 和 g++的区别**

简单来说，gcc与g++都是GNU(组织)的一个编译器。需要注意以下几点：

1. gcc与g++都可以编译c代码与c++代码。但是：后缀为.c的，gcc把它当做C程序，而g++当做是C++程序；后缀为.cpp的，两者都会认为是C++程序。
2. 编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接。
3. 编译可以用gcc/g++，而链接可以用g++或者gcc -lstdc++。因为gcc命令不能自动和C＋＋程序使用的库联接（当然可以选择手动链接，使用命令如下），所以通常使用g++来完成联接。但在编译阶段，g++会自动调用gcc，二者等价。

```text
gcc main.cpp -lstdc++
```









### 基本类型

1）整型 int

2）浮点型 单精度float，双精度double

3）字符型 char

4）逻辑型 bool

5）控制型 void

基本类型的字长及其取值范围可以放大和缩小，改变后的类型就叫做基本类型的派生类型。派生类型声明符由基本类型关键字char、int、float、double前面加上类型修饰符组成。

类型修饰符包括：

\>short 短类型，缩短字长

\>long 长类型，加长字长

\>signed 有符号类型，取值范围包括正负值

\>unsigned 无符号类型，取值范围只包括正值









### 关键字

#### 1、**const，static，define**

**const**强调**值不能被修改**，为**只读变量**（非常量），拥有类型检查；



static强调**唯一的拷贝**，同时**限制作用域**；static变量是无法extern的

​     static可以用来定义：全局静态变量、局部静态变量、静态函数、静态数据成员、静态成员函数。



**define**用来定义常量和宏，只进行简单的字符串替换，没有类型检查，在编译之前，是预编译部分；



##### `const`关键字的作用：

（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；
（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；
（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。



##### `static`关键字的作用：

1）函数体内： static 修饰的局部变量作用范围为该函数体，不同于auto变量，其内存只被分配一次，因此其值在下次调用的时候维持了上次的值

2）模块内：static修饰全局变量或全局函数，可以被模块内的所有函数访问，但是不能被模块外的其他函数访问，使用范围限制在声明它的模块内

3）类中：修饰成员变量，表示该变量属于整个类所有，对类的所有对象只有一份拷贝

4）类中：修饰成员函数，表示该函数属于整个类所有，不接受this指针，只能访问类中的static成员变量

注意和const的区别！！！const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象





##### define和const的区别

1）#define定义的常量没有类型，所给出的是一个立即数；const定义的常量有类型名字，存放在静态区域

2）处理阶段不同，#define定义的宏变量在预处理时进行替换，可能有多个拷贝，const所定义的变量在编译时确定其值，只有一个拷贝。

3）#define定义的常量是不可以用指针去指向，const定义的常量可以用指针去指向该常量的地址

4）#define可以定义简单的函数，const不可以定义函数



##### 顶层const和底层const

问：const int * a；int const *a；int *const a；const int *const a的区别

const int*a：底层const，指针a指向的对象是const

int const*a：和上述一样，const都在 *的左侧，说明修饰指向的对象

int *const a：顶层const，指针a自身是const

const int * const a：顶层const和底层const都有，都不能变





#### 2、**typedef、 using**

typedef是c语言的关键字，用来**定义类型别名**，有类型检查，是属于编译部分，同时有作用域限制；

using是c++11中的新关键字，和typedef作用一样，但是还可以定义模板的别名；



##### typdef和define区别

\#define是预处理命令，在预处理是执行简单的替换，不做正确性的检查

typedef是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名

typedef (int*) pINT;

\#define pINT2 int*

效果相同？实则不同！实践中见差别：pINT a,b;的效果同int *a; int *b;表示定义了两个整型指针变量。而pINT2 a,b;的效果同int *a, b;表示定义了一个整型指针变量a和整型变量b。







#### 3、**volatile**

volatile是C的指令关键字，用来修饰被不同线程访问和修改的变量（即随时会被意想不到的改变），优化器在用到这个变量时必须每次都去内存中取值，不得使用保存在寄存器中的备份。

volatile是“易变的”、“不稳定”的意思。volatile是C的一个较为少用的关键字，它用来解决变量在“共享”环境下容易出现读取错误的问题。

变量如果加了voletile修饰，则会从内存中重新装载内容，而不是直接从寄存器中拷贝内容。

在本次线程内，当读取一个变量时，为了提高读取速度，**编译器进行优化时有时会先把变量读取到一个寄存器中**；以后，再读取变量值时，就直接从寄存器中读取；当变量值在本线程里改变时，会同时把变量的新值copy到该**寄存器**中，以保持一致。当变量因别的线程值发生改变，上面寄存器的值不会相应改变，从而造成应用程序读取的值和实际的变量值不一致。

volatile可以避免优化、强制内存读取的顺序，但是volatile并没有线程同步的语义，C++标准并不能保证它在多线程情况的正确性。C++11开始有一个很好用的库，那就是atomic类模板，在<atomic>头文件中，多个线程对atomic对象进行访问是安全的，并且提供不同种类的线程同步。它默认使用的是最强的同步，所以我们就使用默认的就好。





### 指针和引用

#### 1、指针和引用的区别

1）指针是一个新的变量，存储了另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；

引用只是一个别名，还是变量本身，对引用的任何操作就是对变量本身进行操作，以达到修改变量的目的

2）引用只有一级，而指针可以有多级

3）指针传参的时候，还是值传递，指针本身的值不可以修改，需要通过解引用才能对指向的对象进行操作

引用传参的时候，传进来的就是变量本身，因此变量可以被修改





#### 2、指针函数和函数指针

指针函数：一个函数，返回值是指针。

函数指针：一个指针，指向函数。

注：函数指针声明的时候 * 需要和函数名用括号括起来(优先级原因)

```c
int add(int x,int y){
    return x + y;
}
int (*fun) (int,int);//声明函数指针,参数列表得和指向的函数一致
fun = &add;         //fun函数指针指向add函数
```





#### 3、空悬指针和野指针

**野指针**：未初始化的指针

**空悬指针**：指向已释放内存的指针

产生原因：

- 声明时未初始化
- 指针被free或delete之后没有被置nullptr
- 指针操作超越了变量的作用范围

避免：

- 声明时初始化，或者置nullptr
- 指针指向的内存空间被释放后应指向nullptr
- 在变量的作用域结束前释放掉变量的地址空间并且将指针置nullptr
- 使用指针前记得检查指针的合法性
- 使用智能指针shared_ptr来防止野指针。







#### 4、引用作为函数参数以及返回值的好处

对比值传递，引用传参的好处：

1）在函数内部可以对此参数进行修改

2）提高函数调用和运行的效率（所以没有了传值和生成副本的时间和空间消耗）

如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参=实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。

用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。

但是有以下的限制：

1）不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁

2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak

3）可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。







### 内存管理

#### 1、c++内存的几个区域

5个区：

**栈**：函数的参数和局部变量，编译器自动分配和释放

**堆**：用于动态分配内存，由程序员手动进行释放，否则程序结束后，由操作系统自动进行回收

**代码存储区**：存储机器代码

**全局、静态存储区**：编译期已分配好，整个程序运行期间一直存在，放全局和静态变量

**常量存储区**：存放常量，不允许修改



![](https://cdncontribute.geeksforgeeks.org/wp-content/uploads/memoryLayoutC.jpg)





#### 2、C++内存的分配机制

**.text：已编译程序的机器代码**

.rodata：只读数据

**.data**：已初始化的全局变量和静态变量；

**.bss**：未初始化的静态变量，以及所有初始化为0的全局或静态变量；

**COMMON**：未初始化的全局变量（现代GCC中，之前也在.bss中）

.symtab：符号表

.rel.text，.rel.data，.debug，.line，.strtab



#### 3、堆和栈的区别

1）栈 stack 存放函数的参数值、局部变量，由编译器自动分配释放

堆heap，是由new分配的内存块，由应用程序控制，需要程序员手动利用delete释放，如果没有，程序结束后，操作系统自动回收

2）因为堆的分配需要使用频繁的new/delete，造成内存空间的不连续，会有大量的碎片

3）堆的生长空间向上，地址越大，栈的生长空间向下，地址越小





#### 4、new、delete和malloc、free

##### 1、联系：

​    都可以用于申请动态内存和释放内存



##### 2、区别

（1）new/delete是c++的运算符，可以重载，malloc/free是c的库函数，可以覆盖

（2）new建立的是一个对象，malloc分配的是一块内存，且对开辟的空间大小严格指定

（3）new调用构造函数，delete调用析构函数，对于非内置类型来说，malloc/free无法做到

（4）new/delete返回的是某种类型的指针，malloc/free返回的是void*指针



##### 3、既然有了malloc/free，C++中为什么还需要new/delete呢？

运算符是语言自身的特性，有固定的语义，编译器知道意味着什么，由编译器解释语义，生成相应的代码。

库函数是依赖于库的，一定程度上独立于语言的。编译器不关心库函数的作用，只保证编译，调用函数参数和返回值符合语法，生成call函数的代码。

malloc/free是库函数，new/delete是C++运算符。对于非内部数据类型而言，光用malloc/free无法满足动态对象都要求。new/delete是运算符，编译器保证调用构造和析构函数对对象进行初始化/析构。但是库函数malloc/free是库函数，不会执行构造/析构。



##### 4、delete和delete[]的区别

delete只会调用一次析构函数，而delete[]会调用每个成员的析构函数

用new分配的内存用delete释放，用new[]分配的内存用delete[]释放







##### 5、怎样判断new返回是否成功

1）使用`try catch`

**由于C++里new分配内存失败，默认是抛出异常并跳过后面代码**。此时无法用判断指针是否为空指针的方法。

```c++
try{
	int* p = new int[SIZE];
	//其他代码
}catch(const bad_alloc& e){
     return -1;
}
```

2）抑制`new`抛出异常，此时失败会返回空指针

```c++
int* p = new (std::nothrow) int; //此时new失败不会抛出异常，而是返回空指针
if(p==nullptr )//如此这般，这个判断就有意义了
	return -1；
//其他代码
```



##### 6、用new申请的堆空间使用free释放会怎样

自定义类型（结构体）肯定是没法释放掉堆空间的。

内置类型（如int）原理上来说也是可以释放的，但是有可能会出现各种意想不到的错误，同时，某些编译器可能会禁止使用free来释放new申请的堆内存，可能会编译错误。









#### 5、内存泄漏

内存泄漏是指己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。



##### 几种情况

1）类的构造函数和析构函数中new和delete没有配套

2）在释放对象数组时没有使用delete[]，使用了delete

3）没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露

4）没有正确的清楚嵌套的对象指针



##### 解决方法：

malloc/free要配套，对指针赋值的时候应该注意被赋值的指针是否需要释放；使用的时候记得指针的长度，防止越界











#### 6、栈溢出的原因以及解决方法

栈溢出是指函数中的局部变量造成的溢出（注：函数中形参和函数中的局部变量存放在栈上）

栈的大小通常是1M-2M,所以栈溢出包含两种情况，一是分配的的大小超过栈的最大值，二是分配的大小没有超过最大值，但是接收的buf比原buf小。

1）函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈

2）局部变量体积太大。

解决办法大致说来也有两种：

1> 增加栈内存的数目；如果是不超过栈大小但是分配值小的，就增大分配的大小

2> 使用堆内存；具体实现由很多种方法可以直接把数组定义改成指针,然后动态申请内存;也可以把局部变量变成全局变量,一个偷懒的办法是直接在定义前边加个static,呵呵,直接变成静态变量(实质就是全局变量)













### 类、继承和多态

#### 1、结构体struct和union的区别

结构体：将不同类型的数据组合成一个整体，是自定义类型

共同体：不同类型的几个变量共同占用一段内存

1）结构体中的每个成员都有自己独立的地址，它们是同时存在的；

共同体中的所有成员占用同一段内存，它们不能同时存在；

2）sizeof(struct)是内存对齐后所有成员长度的总和，sizeof(union)是内存对齐后最长数据成员的长度、

结构体为什么要内存对齐呢？

1.平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常

2.硬件原因：经过内存对齐之后，CPU的内存访问速度大大提升。



#### 2、struct和class的区别



#### 3、面向对象三大特性



封装可以隐藏实现细节，使得代码模块化；

继承可以扩展已存在的代码模块（类）

多态：不同对象接收相同的消息产生不同的动作。多态包括 **编译时多态**和 **运行时多态**

运行时多态是：通过继承和虚函数来体现的。
编译时多态：运算符重载和函数重载。



#### 4、静态绑定和动态绑定

##### 静态绑定和动态绑定是C++多态性的一种特性

1）对象的静态类型和动态类型

静态类型：对象在声明时采用的类型，在编译时确定

动态类型：当前对象所指的类型，在运行期决定，对象的动态类型可变，静态类型无法更改

2）静态绑定和动态绑定

静态绑定：绑定的是对象的静态类型，函数依赖于对象的静态类型，在编译期确定

动态绑定：绑定的是对象的动态类型，函数依赖于对象的动态类型，在运行期确定

只有虚函数才使用的是动态绑定，其他的全部是静态绑定



##### 引用为什么能实现动态绑定

因为引用（或指针）既可以指向基类对象也可以指向派生类对象，这一事实是动态绑定的关键。用引用（或指针）调用的虚函数在运行时确定，被调用的函数是引用（或指针）所指的对象的实际类型所定义的。





#### 5、虚函数


多态也有代码重用的功能，还有解决项目中紧耦合的问题，提高程序的可扩展性。C++实现多态的机制很简单，在继承体系下，将父类的某个函数设置成虚函数（即加上virtual关键字），在派生类中对这个虚函数进行重写，利用父类的指针或引用调用虚函数。通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数。对于虚函数调用来说，每一个**对象**内部都有**一个**虚表指针，在构造子类对象时，执行构造函数中进行虚表的创建和虚表指针的初始化，该虚表指针被初始化为**本类的虚表**。所以在程序中，不管你的对象类型如何转换，但该对象内部的虚表指针是固定的，所以呢，才能实现动态的对象函数调用，这就是C++多态性实现的原理。
需要注意的几点**总结**（基类有虚函数）：
1、每一个类都有虚表，单继承的子类拥有一张虚表，子类对象拥有一个虚表指针；若子类是多重继承（同时**继承多个基类**），则子类维护多张虚函数表（针对不同基类构建不同虚表），该子类的对象也将包含**多个虚表指针**。

2、虚表可以继承，如果子类没有重写虚函数，那么子类虚表中仍然会有该函数的地址，只不过这个地址指向的是基类的虚函数实现。如果基类3个虚函数，那么基类的虚表中就有三项（虚函数地址），派生类也会有虚表，至少有三项，如果重写了相应的虚函数，那么虚表中的地址就会改变，指向自身的虚函数实现。如果派生类有自己的虚函数，那么虚表中就会添加该项。
3、派生类的虚表中虚函数地址的排列顺序和基类的虚表中虚函数地址排列顺序相同。

![img](https://pic2.zhimg.com/80/v2-a5c5b566cb563405e0e8b54abf2fb611_720w.jpg)

第一：编译器在发现Father 类中有虚函数时，会自动为每个含有虚函数的类生成一份虚函数表，也叫做虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址。

第二：编译器会在每个对象的前四个字节中保存一个虚表指针，即（vptr),指向对象所属类的虚表。在程序运行时的合适时机，根据对象的类型去初始化vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数。

第三：所谓的合适时机，在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表。





#### 6、纯虚函数

**虚函数**： 在基类中用virtual的成员函数。允许在派生类中对基类的虚函数重新定义。
基类的虚函数可以有函数体，基类也可以实例化。
虚函数要有函数体，否则编译过不去。
虚函数在子类中可以不覆盖。
构造函数不能是虚函数。

**纯虚函数**：基类中为其派生类保留一个名字，以便派生类根据需要进行定义。
包含一个纯虚函数的类是抽象类。
纯虚函数后面有 = 0；
抽象类不可以实例化。但可以定义指针。
如果派生类如果不是先基类的纯虚函数，则仍然是抽象类。
抽象类可以包含虚函数。





#### 7、构造函数和析构函数

##### **构造函数和析构函数都不能被继承。**

1.构造函数和析构函数是用来处理对象的创建和析构的，它们只知道对在它们的特殊层次的对象做什么。所以，在整个层次中内的所有的构造函数和析构函数都必须被调用而不能被继承。

2.子类的构造函数会显式的调用父类的构造函数或隐式的调用父类的默认容的构造函数进行父类部分的初始化。



##### **构造函数不能声明为虚函数**

1）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型，是类本身还是类的派生类等等

2）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了。



##### **析构函数最好声明为虚函数**

首先析构函数可以为虚函数，当析构一个指向派生类的基类指针时，最好将基类的析构函数声明为虚函数，否则可以存在内存泄露的问题。

如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向派生类的基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全。



##### 析构函数为什么默认不是虚函数

虚函数由于包含虚表，效率比普通函数慢，基于效率的考虑，析构函数默认不是虚函数。

若真需要，再使用virtual关键字声明



##### **子类析构时，要调用父类的析构函数吗？**

析构函数调用的次序时先派生类后基类的。和构造函数的执行顺序相反。并且析构函数要是virtual的，否则如果用父类的指针指向子类对象的时候，析构函数静态绑定，不会调用子类的析构。

不用显式调用，会自动调用









#### 8、重载overload、覆盖（重写）override和隐藏（重定义）overwrite

**重载**：函数名相同，参数不同，作用域相同（同一个类中），virtual可有可无

**覆盖**：函数名相同，参数相同，范围不同（子类和基类），基类必有virtual

**隐藏**：派生类中的函数屏蔽了与其同名的基类函数，范围不同，返回值类型可以不同

- 函数名相同，参数不同，无论是否有virtual，隐藏
- 函数名相同，参数相同，基类无virtual时隐藏







#### 9、**友元函数和友元类**

友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。

通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。

友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。

1）友元函数

有元函数是可以访问类的私有成员的非成员函数。它是定义在类外的普通函数，不属于任何类，但是需要在类的定义中加以声明。

friend 类型 函数名(形式参数);

一个函数可以是多个类的友元函数，只需要在各个类中分别声明。

2）友元类

友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。

friend class 类名;

使用友元类时注意：

(1) 友元关系不能被继承。

(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。

(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明









#### 10、调用拷贝构造函数的三种情况

系统自动生成的构造函数：普通构造函数和拷贝构造函数 （在没有定义对应的构造函数的时候）

生成一个实例化的对象会调用一次普通构造函数，而用一个对象去实例化一个新的对象所调用的就是拷贝构造函数

调用拷贝构造函数的情形：

1）用类的一个对象去初始化另一个对象的时候

2）当函数的参数是类的对象时，就是值传递的时候，如果是引用传递则不会调用

3）当函数的返回值是类的对象或者引用的时候

举例：

```text
#include <iostream>
#include <string>
using namespace std;
class A{
	private:
		int data;
	public:
		A(int i){ data = i;} 	//自定义的构造函数
		A(A && a);  			//拷贝构造函数 
		int getdata(){return data;} 
};
//拷贝构造函数 
A::A(A && a){
	data = a.data;
	cout <<"拷贝构造函数执行完毕"<<endl;
}
//参数是对象，值传递，调用拷贝构造函数
int getdata1(A a){
	return a.getdata();
}
//参数是引用，引用传递，不调用拷贝构造函数 
int getdata2(A &a){
	return a.getdata();
} 
//返回值是对象类型，会调用拷贝构造函数
 A getA1(){
 	A a(0);
 	return a;
 } 
 //返回值是引用类型，会调用拷贝构造函数，因为函数体内生成的对象是临时的，离开函数就消失
 A& getA2(){
 	A a(0);
 	return a;
 } 
 int main(){
    A a1(1);  
    A b1(a1);           		//用a1初始化b1，调用拷贝构造函数  
    A c1=a1;            		//用a1初始化c1，调用拷贝构造函数  
    int i=getdata1(a1);        	//函数形参是类的对象，调用拷贝构造函数  
    int j=getdata2(a1);      	//函数形参类型是引用，不调用拷贝构造函数  
    A d1=getA1();       		//调用拷贝构造函数  
    A e1=getA2();     			//调用拷贝构造函数  
    return 0;  
}  
```



#### 11、三五法则

如果一个类需要自定义析构函数，那么它也一定需要自定义拷贝构造函数、重载拷贝赋值运算符。

```
1. 需要析构函数的类也需要拷贝构造函数和拷贝赋值函数。 
2. 需要拷贝操作的类也需要赋值操作，反之亦然。 
3. 析构函数不能是删除的 
4. 如果一个类有删除的或不可访问的析构函数，那么其默认和拷贝构造函数会被定义为删除的。 
5. 如果一个类有const或引用成员，则不能使用合成的拷贝赋值操作。
```







#### 12、内联函数

1. 内联函数的函数体代码替换发生在编译期，而define的宏替换发生在预编译阶段。
2. 声明为inlining的函数只是向编译器建议将其实现为内联的，而实际不一定实现是内联的，这要根据编译器的优化决定
3. 构造函数和析构函数不该声明成inlining函数
4. linine函数无法随着程序库的升级而升级，非内联函数只要重新连接就行不用重新编译
5. 将大多数lining限制在**小型**、**被频繁调用**、**不包含循环和不包含调用其他函数的**函数身上。这可以使得日后的调试过程和二级制升级容易，也使得潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。



速度比较：内联函数  > 普通函数 > 虚函数











### STL模板库

STL包括两部分内容：容器、算法和迭代器

容器即存放数据的地方，比如array, vector，分为两类，序列式容器和关联式容器

**序列式容器**，其中的元素不一定有序，但是都可以被排序，比如vector,list,queue,stack，heap, priority-queue, slist

**关联式容器**，内部结构是一个平衡二叉树，每个元素都有一个键值和一个实值，比如map, set, hashtable, hash_set

算法有排序，复制等，以及各个容器特定的算法

迭代器是STL的精髓，迭代器提供了一种方法，使得它能够按照顺序访问某个容器所含的各个元素，但无需暴露该容器的内部结构，它将容器和算法分开，让二者独立设计，却又完美将容器和算法粘在一起。





#### 1、vector

##### 1、

##### 2、**vector如何扩展内存和释放内存，用clear()能否释放所有内存**

vector就是一个动态增长的数组，里面有一个指针指向一片连续的空间，当空间装不下的时候，会申请一片更大的空间，将原来的数据拷贝过去，并释放原来的旧空间。当删除的时候空间并不会被释放，只是清空了里面的数据。对比array是静态空间一旦配置了就不能改变大小。

vector的动态增加大小的时候，并不是在原有的空间上持续新的空间（无法保证原空间的后面还有可供配置的空间），而是以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，并释放原空间。在VS下是1.5倍扩容，在GCC下是2倍扩容。

在原来空间不够存储新值时，每次调用push_back方法都会重新分配新的空间以满足新数据的添加操作。如果在程序中频繁进行这种操作，还是比较消耗性能的。



##### 3、emplace_back与push_back区别

emplace_back是直接在vector中构造，push_back是拷贝过去



##### 4、vector以及迭代器

每种容器类型都定义了自己的迭代器类型，每种容器都定义了一队命名为begin和end的函数，用于返回迭代器。

迭代器是容器的精髓，它提供了一种方法使得它能够按照顺序访问某个容器所含的各个元素，但无需暴露该容器的内部结构，它将容器和算法分开，让二者独立设计。





##### 5、手写vector

```c++
template<class T>
class MyVector{
public:
    // 构造函数
    MyVector(int len = 0):size(len), capacity(size + SPACE_CPACITY){
        m_data = new T[capacity];
    }
    // 拷贝构造函数
    MyVector(const MyVector& other){
        m_data = new T[other.size()];
        capacity = other.capacity;
        size = other.size;
        for(int i = 0; i < other.size; ++ i)
            m_data[i] = other.m_data[i];
    }
    // 拷贝赋值运算符函数
    MyVector operator =(const MyVector& other){
        if(this != &other){
            T* tmp = m_data;
            m_data = new T[other.capacity];
            size = other.size;
            capacity = other.capacity;
            
            delete[] tmp;
            for(int i = 0; i < other.size; ++ i)
                m_data[i] = other.m_data[i];
        }
        return *this;
    }
    // 析构函数
    ~MyVector(){
        delete[] m_data;
        m_data = nullptr;
        size = capacity = 0;
    }
private:
    const int SPACE_CAPACITY = 16;
    T* m_data;
    int size;
    int capacity;
};
```



#### 2、string







##### 手写string

```c++
class MyString{
public:
    // 构造函数
    MyString(const char* str = nullptr){
        if(str == nullptr){
            m_data = new char[1];
            m_data[0] = '\0';
        }else{
            m_data = new char[strlen(str) + 1];
            strcpy(m_data, str);
        }
    }
    // 拷贝构造函数
    MyString(const MyString& str){
        m_data = new char[strlen(str.m_data) + 1];
        strcpy(m_data, str.m_data);
    }
    // 拷贝赋值运算符函数
    MyString& operator = (const MyString& str){
        if(this != &str){
            delete[] m_data;
            m_data = new char[strlen(sr.m_data) + 1];
            strcpy(m_data, str.m_data);
            return *this;
        }
    }
    // 析构函数
    ~MyString(){
        delete[] m_data;
        m_data = nullptr;
    }
    
private:
    char* m_data;
};
```



#### 3、list



##### vector和list的区别

vector和数组类似，拥有一段连续的内存空间。vector申请的是一段连续的内存，当插入新的元素内存不够时，通常以2倍重新申请更大的一块内存，将原来的元素拷贝过去，释放旧空间。因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。

list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n); 但由于链表的特点，能高效地进行插入和删除。

vector拥有一段连续的内存空间，能很好的支持随机存取，因此vector<int>::iterator支持“+”，“+=”，“<”等操作符。

list的内存空间可以是不连续，它不支持随机访问，因此list<int>::iterator则不支持“+”、“+=”、“<”等

vector<int>::iterator和list<int>::iterator都重载了“++”运算符。

总之，如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector;

如果需要大量的插入和删除，而不关心随机存取，则应使用list。







#### 6、STL中unordered_map和map的区别

map是STL中的一个关联容器，提供键值对的数据管理。底层通过红黑树来实现，实际上是二叉排序树和非严格意义上的二叉平衡树。所以在map内部所有的数据都是有序的，且map的查询、插入、删除操作的时间复杂度都是O(logN)。

unordered_map和map类似，都是存储key-value对，可以通过key快速索引到value，不同的是unordered_map不会根据key进行排序。unordered_map底层是一个防冗余的哈希表，存储时根据key的hash值判断元素是否相同，即unoredered_map内部是无序的。













#### 10、**c++函数库<algorithm>中一些实用的函数**

1. __gcd(x, y)

求两个数的最大公约数，如__gcd(6, 8) 就返回2。

2. reverse(a + 1, a + n + 1)

将数组中的元素反转。a 是数组名，n是长度，跟 sort 的用法一样。值得一提的是，对于字符型数组也同样适用。

3. unique(a + 1, a + n + 1)

去重函数。跟sort的用法一样。不过他返回的值是最后一个数的地址，所以要得到新的数组长度应该这么写： _n = unique(a + 1, a + n + 1) - a - 1.

4.lower_bound(a + 1, a + n + 1, x); upper_bound(a + 1, a + n + 1, x)

lower_bound是查找数组中第一个大于等于x的数，返回该地址，同理也是 pos = lower_bound(a + 1, a + n + 1, x) - a

upper_bound是查找第一个大于x的数，用法和lower_bound一样

复杂度是二分的复杂度，O(logn)。（其实就是代替了手写二分）

5.fill(a + 1, a + n + 1, x)

例如

```
int`数组：`fill(arr, arr + n, 要填入的内容);
vector`也可以：`fill(v.begin(), v.end(), 要填入的内容);
```

fill(vector.begin(), cnt, val); // 从当前起始点开始，将之后的`cnt`个元素赋值为`val`。

memset(arr, val, cnt); // 在头文件`<cstring>`里。

将数组a中的每一个元素都赋成x，跟memset的区别是，memset函数按照字节填充，所以一般memset只能用来填充char型数组，（因为只有char型占一个字节）如果填充int型数组，除了0和-1，其他的不能。





### C++11



1. 类型推导：auto 和 decltype

   

2. 初始化列表

3. 正则表达式

4. 新增容器：std::array, std::forward_list

5. 模板增强

6. 线程支持

   

7. 右值引用(重点)



#### nullptr

nullptr是为了解决传统C++中NULL的二义性问题而引进的一种新的类型，由于NULL可以表示0，也可以表示空指针，在重载时往往把应该看成指针的NULL当做0处理。



#### 类型推导

##### auto

使用 auto 声明一个变量，编译器会自动推导变量的类型。

##### decltype

有点像auto的反函数，decltype则能够从一个变量或表达式中得到类型





#### 范围for循环

简化的for循环，能够用于遍历数组、容器、string以及由begin和end函数定义的序列（即有Iterator的容器）

```c++
vector<int> v;
for (auto x : v)
{
	
}
```





#### lambda表达式

lambda表达式，能够用于创建并定义匿名的函数对象，以简化编程工作。Lambda的语法例如以下： [函数对象參数]（操作符重载函数參数）->返回值类型{函数体}

```c++
vector<int> iv{5, 4, 3, 2, 1};
int a = 2, b = 1;

for_each(iv.begin(), iv.end(), [b](int &x){cout<<(x + b)<<endl;}); // (1)

for_each(iv.begin(), iv.end(), [=](int &x){x *= (a + b);});     // (2)

for_each(iv.begin(), iv.end(), [=](int &x)->int{return x * (a + b);});// (3)
```



- []内的參数指的是Lambda表达式能够取得的全局变量。(1)函数中的b就是指函数能够得到在Lambda表达式外的全局变量，假设在[]中传入= 的话，能够取得全部的外部变量，（2）和（3）,假如在[]中传入&则不光可以使用，还可以修改所有的外部变量。
- ()内的參数是每次调用函数时传入的參数。
- ->后加上的是Lambda表达式返回值的类型。如（3）中返回了一个int类型的变量







#### 变长参数模板

C++11中引入了变长參数模板，所以发明了新的数据类型：tuple，tuple是一个N元组。能够传入1个， 2个甚至多个不同类型的数据

```text
auto t1 = make_tuple(1, 2.0, "C++ 11");
auto t2 = make_tuple(1, 2.0, "C++ 11", {1, 0, 2});
```

避免了从前的pair中嵌套pair的丑陋做法。使得代码更加整洁

**更加优雅的初始化方法，**在引入C++11之前。仅仅有数组能使用初始化列表，其它容器想要使用初始化列表，仅仅能用下面方法：

```text
int arr[3] = {1, 2, 3}
vector<int> v(arr, arr + 3);
```

在C++11中，我们能够使用下面语法来进行替换：

```text
int arr[3]{1, 2, 3};
vector<int> iv{1, 2, 3};
map<int, string>{{1, "a"}, {2, "b"}};
string str{"Hello World"};
```







#### **智能指针**

将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。

智能指针是一个类，这个类的构造函数中传入一个普通指针，析构函数中释放传入的指针。智能指针的类都是栈上的对象，所以当函数（或程序）结束时会自动被释放，

智能指针就是一种栈上创建的对象，函数退出时会调用其析构函数，这个析构函数里面往往就是一堆计数之类的条件判断，如果达到某个条件，就把真正指针指向的空间给释放了。

注意事项：

不能将指针直接赋值给一个智能指针，一个是类，一个是指针。

**常用的智能指针**

智能指针在C++11版本之后提供，包含在头文件<memory>中，shared_ptr、unique_ptr、weak_ptr

1）`std::auto_ptr`，有很多问题。 不支持复制（拷贝构造函数）和赋值（operator =），但复制或赋值的时候不会提示出错。所以可能会造成程序崩溃，比如

```text
auto_ptr<string> p1(new string ("auto") ； //#1
auto_ptr<string> p2;                                    //#2
p2 = p1;                                               //#3
```

在语句#3中，p2接管string对象的所有权后，p1的所有权将被剥夺。前面说过，这是好事，可防止p1和p2的析构函数试图刪同—个对象；
但如果程序随后试图使用p1，这将是件坏事，因为p1不再指向有效的数据。如果再访问p1指向的内容则会导致程序崩溃。

auto_ptr是C++98提供的解决方案，C+11已将将其摒弃，摒弃auto_ptr的原因，一句话总结就是：**避免潜在的内存崩溃问题。**

2) C++11引入的`unique_ptr`， 也不支持复制和赋值，但比auto_ptr好，直接赋值会编译出错。实在想赋值的话，需要使用`std::move`。例如：

```text
std::unique_ptr<int> p1(new int(5))          // #4
std::unique_ptr<int> p2 = p1; // 编译会出错         //#5
std::unique_ptr<int> p3 = std::move(p1); // 转移所有权, 现在那块内存归p3所有, p1成为无效的指针. //#6
```

编译器认为语句#5非法，因此，unique_ptr比auto_ptr更安全。

**但unique_ptr还有更聪明的地方。** 有时候，会将一个智能指针赋给另一个并不会留下危险的悬挂指针。当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做

```text
unique_ptr<string> pu1(new string ("hello world"));
unique_ptr<string> pu2;
pu2 = pu1;                                      // #1 not allowed
unique_ptr<string> pu3;
pu3 = unique_ptr<string>(new string ("You"));   // #2 allowed
```

其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。**这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。**

3) C++11或boost的`shared_ptr`，基于引用计数的智能指针。可随意赋值，直到内存的引用计数为0的时候这个内存会被释放。

4）C++11或boost的`weak_ptr`，弱引用。 引用计数有一个问题就是互相引用形成环，这样两个指针指向的内存都无法释放。需要手动打破循环引用或使用weak_ptr。顾名思义，weak_ptr是一个弱引用，只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前需要检查weak_ptr是否为空指针。



**智能指针的作用**

C++程序设计中使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理。程序员自己管理堆内存可以提高了程序的效率，但是整体来说堆内存的管理是麻烦的，C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，野指针，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。











### 其他重要知识

#### 1、内存对齐

系统需要进行内存对齐，从而提高CPU处理速率，而这项任务就交给编译器进行相应的地址分配和优化，编译器会根据提供参数或者目标环境进行相应的内存对齐

1、平台原因(移植原因)
       A  不是所有的硬件平台都能访问任意地址上的任意数据的；
       B   某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
   2、性能原因：
       A  数据结构(尤其是栈)应该尽可能地在自然边界上对齐。
       B  原因在于为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存仅需要一次访问。





#### 2、C++文件编译与执行的四个阶段

1）预处理：根据文件中的预处理指令来修改源文件的内容

2）编译：编译成汇编代码

3）汇编：把汇编代码翻译成目标机器指令

4）链接：链接目标代码生成可执行程序



##### gcc运行hello.c的例子

一步到位：gcc hello.c
这条命令隐含执行了
（1）预处理
（2）编译
（3）汇编
（4）链接
这里未指定输出文件，默认输出为a.out
gcc编译C源码有四个步骤：
预处理 ----> 编译 ----> 汇编 ----> 链接
现在我们就用gcc的命令选项来逐个剖析gcc过程。
1）预处理(Pre-processing)
在该阶段，编译器将C源代码中的包含的头文件如stdio.h添加进来
参数：”-E”
用法：gcc -E hello.c -o hello.i
作用：将hello.c预处理输出hello.i文件。
2)编译(Compiling)
第二步进行的是编译阶段，在这个阶段中，gcc首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作，在检查无误后，gcc把代码翻译成汇编语言。
参数：”-S”
用法：gcc –S hello.i –o hello.s
作用：将预处理输出文件hello.i汇编成hello.s文件。
3)汇编(Assembling)
汇编阶段是把编译阶段生成的”.s”文件转成二进制目标代码“.o”文件
参数：“-c”
用法：gcc –c hello.s –o hello.o
作用：将汇编输出文件hello.s编译输出hello.o文件。
4）链接(Link)
在成功编译之后，就进入了链接阶段。
用法：gcc hello.o –o hello
作用：将编译输出文件hello.o链接成最终可执行文件hello。
运行该可执行文件，出现正确的结果如下。
\>>> ./hello
Hello World!













#### 3、**C++的四种强制转换**

类型转化机制可以分为隐式类型转换和显示类型转化（强制类型转换）

(new-type) expression

new-type (expression)

隐式类型转换比较常见，在混合类型表达式中经常发生；四种强制类型转换操作符：

**static_cast、dynamic_cast、const_cast、reinterpret_cast**

1）**static_cast** ：编译时期的静态类型检查

static_cast < type-id > ( expression )

该运算符把expression转换成type-id类型，在编译时使用类型信息执行转换，在转换时执行必要的检测（指针越界、类型检查），其操作数相对是安全的

2）**dynamic_cast**：运行时的检查

用于在继承体系中进行安全的向下转换downcast，即基类指针/引用->派生类指针/引用

dynamic_cast是4个转换中唯一的RTTI操作符，提供运行时类型检查。

dynamic_cast如果不能转换返回NULL

dynamic_cast转为引用类型的时候转型失败会抛bad_cast

源类中必须要有虚函数，保证多态，才能使用dynamic_cast<source>(expression)

3）**const_cast**

去除const常量属性，使其可以修改 ; volatile属性的转换

4）**reinterpret_cast**

通常为了将一种数据类型转换成另一种数据类型



##### C++的四种新式转型：

（1）**const_cast<T>(A)**    :  将对象的常量性（const）移除，是唯一的能去掉const的转型操作符

（2）**dynamic_cast<T>(A)**： 安全向下转型，用来决定某对象是否归属继承体系中的某个类型（效率可能会是四种转型中最低的）

（3）**reinterpret_cast<T>(A)**：执行低级转型（例如 int*-->int），实际结果可能取决于编译器

（4）**static_cast<T>(A)**： 强迫隐式转换(例如int-->double，非const-->const等)



结论：（1）如果可以，尽量避免转型，特别是在注重效率的代码中避免使用dynamic_cast，如果有  					个设计需要转型动作，试着发展无需转型的替代设计

​			（2）如果转型是必要的，试着将它隐藏于某个函数背后，客户随后可以调用该函数，而不需将						转型放进自己代码中

​			（3）宁可使用C++风格的新式转型，也不要使用旧式转型（例如int b=(int)a;a为double型）。						前者很容易辨认，而且也有着分门别类的职责









#### 4、线程安全和线程不安全

线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可以使用，不会出现数据不一致或者数据污染。

线程不安全就是不提供数据访问保护，有可能多个线程先后更改数据所得到的数据就是脏数据。

一个线程安全的**class**应满足以下三个条件

- 多线程同时访问时，其表现出正确的行为
- 无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织，调用端代码无需额外的同步或者其他协调动作









#### 5、调试程序的方法

windows下直接使用vs的debug功能

linux下直接使用gdb，我们可以在其过程中给程序添加断点，监视等辅助手段，监控其行为是否与我们设计相符





#### 6、深拷贝和浅拷贝

深拷贝和浅拷贝可以简单的理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，如果资源重新分配了就是深拷贝；反之没有重新分配资源，就是浅拷贝。

看有没有重新分配一块内存，如果有的话就是深拷贝，否则就是浅拷贝。





#### 7、左值和右值，右值引用和move

##### 左值和右值

在c语言中：左值就是可以位于赋值语句左侧的值：例如一个变量

在c语言中：右值就是不能位于赋值语句左侧的值：例如字面值常量或者临时对象

在c++中更为复杂

```c++
int i;
i = 2; // i可以放在=左边， i是一个左值
2 = 3; // 错误！！ 2不能放在=左边，2是一个右值

vector<int> a({1, 2}); // 这句代码中使用一个临时的对象vertor<int>(1, 2)初始化a
//这里的vector<int>(1, 2)就是一个临时对象，是一个右值，a的初始化一旦完成，其就被销毁
```



##### 左值和右值的区别

**左值持久，右值短暂**

当一个对象被用作左值时，用的是对象的身份：**在内存中的位置**；

当这个对象被用作右值时，用的是对象的内容：**值**



因此区分左值和右值可以直接看两点：

- **没有地址只有值**的是右值，例如：233

- 有地址，但是不持久（马上就被销毁）的值是临时右值

  



几个重要的原则：

- 右值能用的地方左值也能用，左值被当做右值使用时使用的是它的值，不关心它的位置
- 左值能用的地方右值却不一定能用
- 左值和右值是表达式的属性：左值表达式表示的是对象的身份，右值表达式表示的是对象的值





##### 右值引用（c++11 新特性）

**右值引用就是必须绑定到右值上的引用**

重要性质：**只能绑定到一个将要销毁的对象**！！

与右值引用相对的：**左值引用**必须绑定到左值上



```c++
int i = 42;       // i是左值， 42是字面值常量，是右值
int &r = i;       // r是i的一个引用：左值引用
int &&rr = i;     // 错误：不能讲一个右值引用绑定到一个左值上
int &r2 = i * 42; // 错误：i * 42 是一个右值表达式
cosnt int &r3 = i * 42; // 正确，一个右值可以绑定到一个const引用上
int &&rr2 = i * 42; // 正确 ：i * 42是一个右值，可以绑定到右值引用rr2上

//注：上面的例子来自 《C++ primer》
```





由右值引用的重要性质可以得知：

因为这个对象将要被销毁，且该对象没有其他用户，所以可以自由的将右值引用的资源“移动”到另一个对象中，即使用右值引用的代码可以自由地接管所引用对象的资源。





##### std::move

虽然**一个右值引用不能绑定到一个变量**上（因为变量都是左值，就算这个变量是一个右值引用类型也不行），但是可以显式地将一个左值转换为对应的右值引用类型。



**std::move**函数：可以获得绑定到左值上的右值引用

```c++
int &&rr1 = 42;  // rr1是一个右值引用类型的变量
int &&rr2 = rr1; // 错误：表达式rr1是左值
int &&rr3 = std::move(rr1); // 正确
```

使用move调用就是告诉编译器：

我们有一个左值，但是我们希望像一个右值一样处理它。



使用move就意味着承诺：除了对这个对象赋值和销毁外，我们保证不再使用它。

（就像使用const 就意味着承诺不再改变变量的值，如果我们试图改变，编译器会报错一样）





理解：为什么要有右值引用和move？

（以下是《C++primer》中介绍加个人理解，不对之处请包涵：）

1）在很多情况下都会发生对象拷贝，比如赋值。而在某些情况下，对象拷贝后就立刻销毁了，此时拷贝对象不如移动对象性能快，移动对象（特别是string类）而不是拷贝对象是比较好的选择。

2）一些IO类或者unique_ptr这样的类，都包含了不能被共享的资源。比如unique_ptr就将了拷贝构造函数和拷贝赋值运算符函数定义为删除的来禁止对象的拷贝。在这种情况下，对象不能拷贝，但是可以移动。因此unique_ptr没有禁止移动构造函数和移动赋值运算符，即unique_ptr是可以移动对象所有权的。

