---
layout: post
title: C++基础知识
date: 2021-01-20
categories: blog
tags: [编程,C++]
description: 文章金句。
---


## C++

### C语言知识

#### 1、C 与 C++ 的区别

- C是面向过程的语言，是一个结构化的语言，考虑如何通过一个过程对输入进行处理得到输出。C++是面向对象的语言，主要特征是“封装、继承和多态”。封装隐藏了实现细节，使得代码模块化；派生类可以继承父类的数据和方法，扩展了已经存在的模块，实现了代码重用；多态则是“一个接口，多种实现”，通过派生类重写父类的虚函数，实现了接口的重用。
- C 和 C++ 动态管理内存的方法不一样，C是使用`malloc/free`，而 C++ 除此之外还有`new/delete`关键字。
- C++ 支持函数重载，C 不支持函数重载
- C++ 中有引用，C 中不存在引用的概念





#### 2、extern“C” 作用

extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。





#### 3、C语言的函数调用过程

函数的调用过程：

1）从栈空间分配存储空间

2）从实参的存储空间复制值到形参栈空间

3）进行运算

形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。

数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。

当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址/指针传递。

传值：传值，实际是把实参的值赋值给行参，相当于copy。那么对行参的修改，不会影响实参的值 

传址： 实际是传值的一种特殊方式，只是他传递的是地址，不是普通的赋值，那么传地址以后，实参和行参都指向同一个对象，因此对形参的修改会影响到实参。



#### 4、`sizeof`和`strlen`

##### **1、sizeof操作符**

`sizeof`计算的是在栈中分配的内存大小。

（1） `sizeof`不计算static变量占的内存；

（2） 32位系统的指针的大小是4个字节，64位系统的指针是8字节，而不用管指针类型；

（3） char型占1个字节，int占4个字节，short int占2个字节

long int占4个字节，float占4字节，double占8字节，string占4字节

一个空类占1个字节，单一继承的空类占1个字节，虚继承涉及到虚指针所以占4个字节

（4） 数组的长度：

若指定了数组长度，则不看元素个数，总字节数=数组长度*sizeof（元素类型）

若没有指定长度，则按实际元素个数类确定

Ps：若是字符数组，则应考虑末尾的空字符。

（5） 结构体对象的长度

在默认情况下，为方便对结构体内元素的访问和管理，当结构体内元素长度小于处理器位数的时候，便**以结构体内最长的数据元素的长度为对齐单位**，即为其整数倍。若结构体内元素长度大于处理器位数则以处理器位数为单位对齐。

栗子：结构体里有一个int，一个short，一个char，sizeof大小为12字节

（6） unsigned影响的只是最高位的意义，数据长度不会改变，所以sizeof(unsigned int) == 4

（7） 自定义类型的sizeof取值等于它的类型原型取sizeof

（8） 对函数使用sizeof，在编译阶段会被函数的返回值的类型代替

（9） sizeof后如果是类型名则必须加括号，如果是变量名可以不加括号，这是因为sizeof是运算符

（10） 当使用结构类型或者变量时，sizeof返回实际的大小。当使用静态数组时返回数组的全部大小，sizeof不能返回动态数组或者外部数组的尺寸



##### 2、strlen

`strlen`是C语言的库函数，计算的是字符串的实际长度，不包括结尾的 ’\0‘。

参数必须是以’\0‘为结尾的字符串。



手动实现

```c++
int strlen(const char *str)
{
	assert(str! = NULL);
	int len = 0;
	while(str != '\0'){
        ++ str;	++ len;
	}
	return len;
}
```





##### 3、sizeof和strlen的区别

1. sizeof是一个操作符，而strlen是库函数。
2. sizeof的参数可以是数据类型或变量，而strlen的参数只能是以’\0‘为结尾的字符串。
3. sizeof计算的是数据类型或变量占内存的大小，而strlen计算的是字符串的实际长度，不包括结尾的 ’\0‘。
4. sizeof在编译时计算结果，而strlen的结果必须在运行时得出。
5. 数组作为sizeof的参数时不退化，传递给strlen时退化为指针。





#### 5、`strcat`

`strcnt`为字符串拼接函数，在`<string.h>`中，函数原型如下：

```c++
char* strcat(char* strDestination, const char* strSource);
```

1、参数说明：

- `strDestination`：目的字符串；

- `strSource`：源字符串。

- 返回：指向 `strDestination` 的指针。

  

**`strcat()`** 函数把 strSource 所指向的字符串追加到 strDestination 所指向的字符串的结尾，所以必须要保证 strDestination 有足够的内存空间来容纳两个字符串，否则会导致溢出错误。

注意：

1）缓冲区 与 目的字符串所指的内存空间不能重叠，且 dest 要有足够的空间来容纳要复制的字符串。

2）strDestination 末尾的`\0`会被覆盖，strSource 末尾的`\0`会一起被复制过去，最终的字符串只有一个`\0`。





2、手动实现`strcnt()`函数

```c++
#include <assert.h>

char* strcnt(char* Dest, const char* Src)
{//注：原函数就没有长度判定
    //assert(Dest != nullptr && Src != nullptr);
    if(Dest == nullptr || Src == nullptr) return Dest;
    if(Dest == Src) return Dest;
    
    char* ret = Dest;
    while(*Dest != '\0') Dest ++;
    while(*Src != '\0'){
        *Dest = *Src;
        *Dest ++, *Src ++;
    }
    *Dest = '\0';
    return ret;
}
```







#### 6、`strcpy`

```c++
char *strcpy(char *dst, const char const *src);
//C语言标准库函数strcpy，把从src地址开始且含有'\0'结束符的字符串复制到以dest开始的地址空间
//注：这个函数没有字符串长度合法判定，而且是个不安全的函数
```

1、这个函数使用需要注意的地方

- 源字符串和目的字符串的存储地址不能有重叠，若出现重叠，其结果是未定义的
- 源字符串长度不能比缓冲区长度更长，因为这个函数没有字符串长度合法判定
- 目的缓冲区是要修改的地方，故`dst`不能是`const`的
- 这个函数将字符串`src`后面的字符串结束符`'\0'`一起复制给`dst`，但是在读取`dst`时由于遇到`'\0'`就会返回，所以不会注意到后面可能还有`'\0'`



2、手动实现`strcpy()`函数

```c++
char *strcpy(char *strDest, const char *strSrc)
{ //注：原函数就没有长度判定
    if ( strDest == NULL || strSrc == NULL)
   		return NULL ;
    if ( strDest == strSrc)
    	return strDest ;
    char *tempptr = strDest ;
    while(*strSrc!='\0'){
        *strDest = *strSrc;
        *strDest++,  *strSrc++;
    }
    //while( (*strDest++ = *strSrc++) != '\0');
    *strDest = '\0';
    return tempptr;
}
```



3、更为安全的`strcpy_s`函数

`c++`提供的`strcpy_s`函数包含在头文件`<string.h>`中

```c++
_ACRTIMP errno_t __cdecl strcpy_s(
        _Out_writes_z_(_SizeInBytes) char*       _Destination,
        _In_                         rsize_t     _SizeInBytes,
        _In_z_                       char const* _Source
        );
```

第一个参数：目标字符串指针

第二个参数：目标缓冲区的实际大小，可使用`strlen()`函数直接求出，切记，在使用`strlen()`求出字符串长度时，勿忘+1

第三个参数：输入字符串指针



一个栗子：

```c++
strcpy_s(str, len+1, s); //将s中字符串复制到str，最后一个空间为'\0'结束符
```











#### 7、`strncpy`

```c++
char *strncpy(char *dest, const char *src, size_t n)
```

1、函数介绍

- **`dest`** -- 指向用于存储复制内容的目标数组。

- **`src`** -- 要复制的字符串。

- **n** -- 要从源中复制的字符数。

  

  该函数返回最终复制的字符串。

注意：

1）库函数 **`strncpy`** 把 **`src`** 所指向的字符串复制到 **`dest`**，最多复制 **n** 个字符。

2)  当`dest`和`src`在内存中有重叠时，结果将是未定义的

3）当 `src` 的长度小于 n 时，`dest` 的剩余部分将用空字节(`‘\0’`)填充。

4）`strncpy`是不负责检测 n`是否大于dest`长度的，因此当n的长度大于strlen(dest)时会破坏后面的内存，因为`strncpy`总是复制`n`个字符到`dest`指向的内存！！！



2、手动实现`strncpy()`函数

1）不考虑内存重叠

```c++
char* strncpy(char* dest, const char* src, size_t n){
    assert(dest != nullptr && src != nullptr);
    char* res = dest;
    int offset = 0; // 多余的部分补空字节
    int len = str(src);
    if(len < n){
        offset = n - len;
        n = len;
    }
    while(n --) 
        *dest ++ = *src ++;
    
    while(offset --) 
        *dest ++ = '\0';
    
    return res;
}
```

2）考虑内存重叠

```c++
char* strncpy(char* dest, const char* src, size_t n){
    assert(dest != nullptr && src != nullptr);
    char* res = dest;
    int offset = 0; // 多余的部分补空字节
    int len = str(src);
    if(len < n){
        offset = n - len;
        n = len;
    }
    char* tmp;
    if(dest >= src && dest <= src + n - 1)
    { // 重叠，从后向前复制
        dest = dest + n - 1;
        src = src + n - 1;
        tmp = dest;
        while(n --) *dest -- = *src --;
    }else{
        while(n --) 
        	*dest ++ = *src ++;
        tmp = dest;
    }

    while(offset --) 
        *tmp ++ = '\0';
    
    return res;
}
```









#### 8、`memset`

```c++
void *memset(void *str, int c, size_t n)
```

复制字符 **c**（一个无符号字符）到参数 **str** 所指向的字符串的前 **n** 个字符。

参数：

- **str** -- 指向要填充的内存块。
- **c** -- 要被设置的值。该值以 int 形式传递，但是函数在填充内存块时是使用该值的无符号字符形式。
- **n** -- 要被设置为该值的字符数。

返回一个指向存储区 str 的指针。

`memset`可以高效地将数组清空，或者赋值

```c++
int a[100];
memset(a, 0, sizeof a); // 将a数组每一位赋0
memser(a, 0x3f, sizeof a); // 将a数组每一位赋0x3f3f3f3f
// 因为第二个参数是逐字节赋值，即对一个int的四个字节，每一个字节都赋值为0x3f
// 因此数组里的每一位都是0x3f3f3f3f
```







#### 9、`memcpy`

```c++
void *memcpy(void *dest, const void *str, size_t n)
```

内存复制函数：从存储区 **str** 复制 **n** 个字节到存储区 **dest**。

- **dest** -- 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。
- **str** -- 指向要复制的数据源，类型强制转换为 void* 指针。
- **n** -- 要被复制的字节数。

返回一个指向目标存储区 dest 的指针。

注意： 注意当内存有重叠时，src部分会被覆盖



手动实现

```c++
void *memcpy(void *dest, const void *str, size_t n){
	if(dest == NULL && src == NULL) return NULL;

	char *d = (char*)dest;
	char *s = (char*)src;
	while(n--)
        *d ++ = *s ++;
    
	return dest;
}
```







#### 10、sprintf、strcpy 及 memcpy比较

问：完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，这些函数的区别

答：这些函数的区别在于 实现功能以及操作对象不同。

（1）**strcpy** 函数操作的对象是字符串，完成从源字符串到目的字符串的拷贝功能。

（2）**sprintf** 函数操作的对象不限于字符串：虽然目的对象是字符串，但是源对象可以是字符串、也可以是任意基本类型的数据。这个函数主要用来实现（字符串或基本数据类型）向字符串的转换功能。如果源对象是字符串，并且指定 %s 格式符，也可实现字符串拷贝功能。

（3）**memcpy** 函数顾名思义就是内存拷贝，实现将一个内存块的内容复制到另一个内存块这一功能。内存块由其首地址以及长度确定。程序中出现的实体对象，不论是什么类型，其最终表现就是在内存中占据一席之地（一个内存区间或块）。因此，memcpy的操作对象不局限于某一类数据类型，或者说可适用于任意数据类型，只要能给出对象的起始地址和内存长度信息、并且对象具有可操作性即可。鉴于memcpy函数等长拷贝的特点以及数据类型代表的物理意义，memcpy 函数通常限于同种类型数据或对象之间的拷贝，其中当然也包括字符串拷贝以及基本数据类型的拷贝。



对于字符串拷贝来说，用上述三个函数都可以实现，但是其实现的效率和使用的方便程度不同：

• strcpy 无疑是最合适的选择：效率高且调用方便。

• sprintf 要额外指定格式符并且进行格式转化，麻烦且效率不高。

• memcpy 虽然高效，但是需要额外提供拷贝的内存长度这一参数，易错且使用不便；并且如果长度指定过大的话（最优长度是源字符串长度 + 1），还会带来性能的下降。其实 strcpy 函数一般是在内部调用 memcpy 函数或者用汇编直接实现的，以达到高效的目的。因此，使用 memcpy 和 strcpy 拷贝字符串在性能上应该没有什么大的差别。



对于非字符串类型的数据的复制来说，strcpy 和 snprintf 一般就无能为力了，可是对 memcpy 
却没有什么影响。但是，对于基本数据类型来说，尽管可以用 memcpy 进行拷贝，由于有赋值运算符可以方便且高效地进行同种或兼容类型的数据之间的拷贝，所以这种情况下 memcpy 几乎不被使用 。memcpy 的长处是用来实现（通常是内部实现居多）对结构或者数组的拷贝，其目的是或者高效，或者使用方便，甚或两者兼有。





#### 11、<file.h> 和  "file.h" 的区别

　　前者是从标准库路径寻找

　　后者是从当前工作路径

\#include < >格式：引用标准库头文件，编译器从标准库目录开始查找。
		#incluce " "格式：引用非标准库的头文件，编译器先从用户的工作目录开始搜索，找不到后才会去系统配置的库环境变量和用户配置的路径去搜索。







#### 12、动态库与静态库的区别

静态库：链接时放入程序，可产生多个副本

动态库：程序运行时加载，多线程共享





#### 13、定义和声明的区别

声明是告诉编译器变量的类型和名字，不会为变量分配空间

定义需要分配空间，同一个变量可以被声明多次，但是只能被定义一次









#### 14、**c cc cpp hpp inl 这些后缀名都有什么区别?**

C中：

头文件后缀名： .h

源文件后缀名： .c

C++中：

头文件后缀名： .h, .hpp, .hxx

源文件后缀名：.cpp, .cc, .cxx, .C .c++

只是个名称，我们自己知道哪些是同一个东西，能区别开c和c++就行了。

另外，.h和.hpp的区别是：*.h里面只有声明，没有实现，而*.hpp里声明实现都有，后者可以减少.cpp的数量，适合用来编写公用的开源库。

inl 文件是内联函数的源文件。内联函数通常在c++头文件中实现，但有的时候**内联函数较多**或者出于一些别的考虑（使头文件看起来更简洁等），往往会将这部分具体**定义的代码添加到INL文件中**，然后**在该头文件的末尾将其用#include引入**。由此也可以看到inl文件的例外一个用法的影子——**模板函数、模板类的定义代码的存放**。







#### 15、**gcc 和 g++的区别**

简单来说，gcc与g++都是GNU(组织)的一个编译器。需要注意以下几点：

1. gcc与g++都可以编译c代码与c++代码。但是：后缀为.c的，gcc把它当做C程序，而g++当做是C++程序；后缀为.cpp的，两者都会认为是C++程序。
2. 编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接。
3. 编译可以用gcc/g++，而链接可以用g++或者gcc -lstdc++。因为gcc命令不能自动和C＋＋程序使用的库联接（当然可以选择手动链接，使用命令如下），所以通常使用g++来完成联接。但在编译阶段，g++会自动调用gcc，二者等价。

```text
gcc main.cpp -lstdc++
```









### 基本类型

1）整型 int

2）浮点型 单精度float，双精度double

3）字符型 char

4）逻辑型 bool

5）控制型 void

基本类型的字长及其取值范围可以放大和缩小，改变后的类型就叫做基本类型的派生类型。派生类型声明符由基本类型关键字char、int、float、double前面加上类型修饰符组成。

类型修饰符包括：

\>short 短类型，缩短字长

\>long 长类型，加长字长

\>signed 有符号类型，取值范围包括正负值

\>unsigned 无符号类型，取值范围只包括正值









### 关键字

#### 1、**const，static，define**

**const**强调**值不能被修改**，为**只读变量**（非常量），拥有类型检查；



static强调**唯一的拷贝**，同时**限制作用域**；static变量是无法extern的

​     static可以用来定义：全局静态变量、局部静态变量、静态函数、静态数据成员、静态成员函数。



**define**用来定义常量和宏，只进行简单的字符串替换，没有类型检查，在编译之前，是预编译部分；



##### `const`关键字的作用：

（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；
（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；
（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。



##### `static`关键字的作用：

1）函数体内： static 修饰的局部变量作用范围为该函数体，不同于auto变量，其内存只被分配一次，因此其值在下次调用的时候维持了上次的值

2）模块内：static修饰全局变量或全局函数，可以被模块内的所有函数访问，但是不能被模块外的其他函数访问，使用范围限制在声明它的模块内

3）类中：修饰成员变量，表示该变量属于整个类所有，对类的所有对象只有一份拷贝

4）类中：修饰成员函数，表示该函数属于整个类所有，不接受this指针，只能访问类中的static成员变量

注意和const的区别！！！const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象





##### define和const的区别

1）#define定义的常量没有类型，所给出的是一个立即数；const定义的常量有类型名字，存放在静态区域

2）处理阶段不同，#define定义的宏变量在预处理时进行替换，可能有多个拷贝，const所定义的变量在编译时确定其值，只有一个拷贝。

3）#define定义的常量是不可以用指针去指向，const定义的常量可以用指针去指向该常量的地址

4）#define可以定义简单的函数，const不可以定义函数



##### 顶层const和底层const

问：const int * a；int const *a；int *const a；const int *const a的区别

const int*a：底层const，指针a指向的对象是const

int const*a：和上述一样，const都在 *的左侧，说明修饰指向的对象

int *const a：顶层const，指针a自身是const

const int * const a：顶层const和底层const都有，都不能变





#### 2、**typedef、 using**

typedef是c语言的关键字，用来**定义类型别名**，有类型检查，是属于编译部分，同时有作用域限制；

using是c++11中的新关键字，和typedef作用一样，但是还可以定义模板的别名；



##### typdef和define区别

\#define是预处理命令，在预处理是执行简单的替换，不做正确性的检查

typedef是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名

typedef (int*) pINT;

\#define pINT2 int*

效果相同？实则不同！实践中见差别：pINT a,b;的效果同int *a; int *b;表示定义了两个整型指针变量。而pINT2 a,b;的效果同int *a, b;表示定义了一个整型指针变量a和整型变量b。







#### 3、**volatile**

volatile是C的指令关键字，用来修饰被不同线程访问和修改的变量（即随时会被意想不到的改变），优化器在用到这个变量时必须每次都去内存中取值，不得使用保存在寄存器中的备份。

volatile是“易变的”、“不稳定”的意思。volatile是C的一个较为少用的关键字，它用来解决变量在“共享”环境下容易出现读取错误的问题。

变量如果加了voletile修饰，则会从内存中重新装载内容，而不是直接从寄存器中拷贝内容。

在本次线程内，当读取一个变量时，为了提高读取速度，**编译器进行优化时有时会先把变量读取到一个寄存器中**；以后，再读取变量值时，就直接从寄存器中读取；当变量值在本线程里改变时，会同时把变量的新值copy到该**寄存器**中，以保持一致。当变量因别的线程值发生改变，上面寄存器的值不会相应改变，从而造成应用程序读取的值和实际的变量值不一致。

volatile可以避免优化、强制内存读取的顺序，但是volatile并没有线程同步的语义，C++标准并不能保证它在多线程情况的正确性。C++11开始有一个很好用的库，那就是atomic类模板，在<atomic>头文件中，多个线程对atomic对象进行访问是安全的，并且提供不同种类的线程同步。它默认使用的是最强的同步，所以我们就使用默认的就好。

